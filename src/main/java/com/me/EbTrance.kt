package com.me

import org.junit.Test
import java.util.regex.Matcher
import java.util.regex.Pattern

class EbTrance {
    @Test
    fun gg() {
        println(1.2 - 1.1)
    }

    @Test
    fun gg1() {
        var str = """
    EXID            string  `json:"EX_ID"`             // 测试id
	EXNAME          string  `json:"EX_NAME"`           // 测试名字
	ENDTIMEUNIX     int64   `json:"END_TIME_UNIX"`     // 测试时间
	HOMEWORKSCORE   float64 `json:"HOMEWORK_SCORE"`    // 作业总分
	MINSTUDENTSCORE float64 `json:"MIN_STUDENT_SCORE"` // 最低分
	MAXSTUDENTSCORE float64 `json:"MAX_STUDENT_SCORE"` // 最高分
	AVGSTUDENTSCORE float64 `json:"AVG_STUDENT_SCORE"` // 平均分
	TOTALCOUNT      int64   `json:"TOTAL_COUNT"`       // 总人数
	EXCELLENTCOUNT  int64   `json:"EXCELLENT_COUNT"`   // 优秀人数
	PASSINGCOUNT    int64   `json:"PASSING_COUNT"`     // 通过人数
	BADCOUNT        int64   `json:"BAD_COUNT"`         // 低分人数
            """
        str = str.replace(""".*"(\w+)".*""".toRegex(), """$1""").toLowerCase()
        var find = """^.""".toRegex().find(str)
        str = str.replace("""^.""".toRegex(), """$1""").toLowerCase()
    }

    @Test
    fun op() {
        val `in` = "\\a\\bnf\\fv"
        println("in is= $`in`")
        val sb = StringBuffer()
        val p: Pattern = Pattern.compile("""\\[a-z|A-Z]""")
        val m: Matcher = p.matcher(`in`)
        while (m.find()) {
            m.appendReplacement(sb, """\""" + m.group().toUpperCase())
            println("m.group() is= " + m.group())
        }
        m.appendTail(sb)
        println("sb is= $sb")
    }


    @Test
    fun xx11() {
        var str = """
type AutoGenerated struct {
	UserList []UserList `json:"UserList"`
	PageInfo PageInfo   `json:"PageInfo"`
}
type UserList struct {
	NickName  string `json:"NickName"`
	Status    string `json:"Status"`
	Company   string `json:"Company"`
	LeaveDate string `json:"LeaveDate"`
	JoinDate  string `json:"JoinDate"`
	Role      string `json:"Role"`
}
type PageInfo struct {
	Page  int `json:"Page"`
	Size  int `json:"Size"`
	Total int `json:"Total"`
}
"""
        str = str.replace("""type (\w+)List""".toRegex(), """type $1Item""")
        str = str.replace("""\[](\w+)List""".toRegex(), """[]$1Item""")
        str = str.replace("""type (\w+) .*\{""".toRegex(), """message $1 {""")
        str = str.replace("""`.*`""".toRegex(), "")
        val itemRegex = """\t(\w+)\s+(.*?) """.toRegex()
        val mgRegex = """(?s)message(.*?)}""".toRegex()
        var newStr = ""
        for ((index, mainMr) in mgRegex.findAll(str).withIndex()) {
            var i = 1
            var xx = mainMr.value
            for (mr in itemRegex.findAll(xx)) {
                val t = "    ${mr.groupValues[2]} ${mr.groupValues[1]} = $i;"
                xx = xx.replace(mr.value, t)
                i++
            }
            if (index == 0) {
                xx = xx.substring(0, xx.length - 1)
            }
            newStr += xx
            if (index > 0) {
                newStr += "\n"
            }
        }
        str = "$newStr}"
        str = str.replace("""int """, "int32 ")
        str = str.replace("""time\.Time """.toRegex(), "string ")
        str = str.replace("""\[]""".toRegex(), "repeated ")
        str = str.replace("""\*""".toRegex(), "")
        str = str.replace("float64", "double")

        str = str.replace("Req_", "Rsp_")
        str = str.replace("ID", "Id")
        str = str.replace("API", "Api")
        str = str.replace("URL", "Url")
        println(str)
    }
}